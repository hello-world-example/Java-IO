<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java IO on Java-IO</title>
    <link>https://hello-world-example.github.io/Java-IO/</link>
    <description>Recent content in Java IO on Java-IO</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://hello-world-example.github.io/Java-IO/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-IO/_sidebar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-IO/_sidebar/</guid>
      <description> 简介 BIO NIO  Channel Buffer Selector   AIO  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-IO/docs/NIO/buffer/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-IO/docs/NIO/buffer/README/</guid>
      <description>Buffer Buffer 用于和NIO Channel 进行交互，数据是从通道读入缓冲区，从缓冲区写入到通道中的。
缓冲区本质上是一块可以读写数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。
核心概念  position：表示当前位置的指针  初始值为 0，最大可为 Buffer 的大小 写数据时，每次写，position 会向后移 从写模式 切换到 读模式时，position 会被重置为 0，每次读，position 会向后移   limit  初始模式下 limit = capacity 写模式下 limit = capacity 切换读模式时，limit = position，position 重置为 0，limit 表示可以读数据的结束位置   capacity：Buffer 的固定大小值  常用方法  flip() 读写模式切换，limit = position，position 重置为 0 clear() 清空整个 Buffer，position=0 置为0、limit = capacity 为可写入的数据大小 compact() 只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。 mark() 标记一个 position 的位置，通过 reset() 恢复 position 位置 rewind() position 重置为 0，与flip() 的区别是 limit 不变，只重置 position，这样可以重新读 slice() 创建 [position,limit) 之间的子 Buffer，父子共享数据  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-IO/docs/NIO/channel/FileChannel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-IO/docs/NIO/channel/FileChannel/</guid>
      <description>FileChannel // TODO 获取 FIle Channel 有几种方式
参考资料  Java NIO系列教程（七） FileChannel  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-IO/docs/NIO/channel/ServerSocketChannel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-IO/docs/NIO/channel/ServerSocketChannel/</guid>
      <description>ServerSocketChannel ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null.如：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-IO/docs/NIO/channel/StandardSocketOptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-IO/docs/NIO/channel/StandardSocketOptions/</guid>
      <description>StandardSocketOptions TODO
https://blog.csdn.net/zero__007/article/details/51723434
   枚举值 说明     IP_MULTICAST_IF This option is used to specify the network interface (NetworkInterface) used for multicast datagrams sent by the datagram-oriented socket; if it is null, then the OS will choose the outgoing interface (if one is available). By default, it is null, but the option’s value can be set after the socket is bound. When we talk about sending datagrams, you will see how to find out what multicast interfaces are available on your machine.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-IO/docs/NIO/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-IO/docs/NIO/README/</guid>
      <description>简介 Java NIO: Channels and Buffers（通道和缓冲区） 标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。
Java NIO: Non-blocking IO（非阻塞IO） Java NIO可以让你非阻塞的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。
Java NIO: Selectors（选择器） Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。
Channel 下面是JAVA NIO中的一些主要Channel的实现：
 FileChannel：从文件中读写数据。 DatagramChannel：能通过UDP读写网络中的数据。 SocketChannel：能通过TCP读写网络中的数据。 ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。  正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。
Buffer 以下是Java NIO里关键的Buffer实现：
 ByteBuffer CharBuffer DoubleBuffer FloatBuffer IntBuffer LongBuffer ShortBuffer  这些Buffer覆盖了你能通过IO发送的基本数据类型：byte, short, int, long, float, double 和 char，没有 boolean。
Java NIO 还有个 MappedByteBuffer，用于表示内存映射文件， 我也不打算在概述中说明。
Selector Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。
要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。
参考资料  原文： Java NIO系列教程（一） Java NIO 概述  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Java-IO/docs/NIO/selector/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Java-IO/docs/NIO/selector/README/</guid>
      <description>Selector Selector 能够检测一个或多个 Channel，知晓通道是否为事件做好准备。这样一个单独的线程可以管理多个Channel，从而管理多个网络连接。
与 Selector 一起使用时，Channel 必须处于非阻塞模式下。这意味着不能将 FileChannel 与 Selector 一起使用，因为FileChannel 不能切换到非阻塞模式，而套接字通道都可以。
核心概念 SelectionKey SelectionKey 中四种事件常量，表示了在通过 Selector 监听 Channel 时，对什么事件感兴趣。通道触发了一个事件意思是该事件已经就绪。
 OP_CONNECT 某个 Channel 成功连接到另一个服务器称为**“连接就绪”** OP_ACCEPT ServerSocketChannel 准备好接收新进入的连接称为**“接收就绪”** OP_READ 有数据可读的通道是**“读就绪”** OP_WRITE 等待写数据的通道是**“写就绪”**  如果你对不止一种事件感兴趣，那么可以用“或”操作符将常量连接起来，如下：
int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; 示例 参考资料  Java NIO 之 Selector 练习  </description>
    </item>
    
  </channel>
</rss>